# ССЫЛКИ
- [СКАЧАТЬ ПРОЕКТ ЦЕЛИКОМ](https://drive.google.com/drive/folders/1-6w-eYeTDt4Sg3uUY5hjvFOTLL-XmesF?usp=sharing)
- [GIT РЕПОЗИТОРИЙ](https://github.com/TeamLight2023/Task6)

# ОСНОВНЫЕ ФАЙЛЫ

## opt_route_1.py
Результат работы над задачей "поиск оптимального числа броневиков".

Класс OptRouteFinder представляет собой алгоритм поиска оптимальных маршрутов при необходимости выполнения заданных в ТЗ условий:
1) обязательно обслуживать терминал, если терминал сегодня будет переполнен
2) обязательно обслуживать терминал раз в 14 дней
Использовался на ФАКТИЧЕСКИХ ДАННЫХ для подбора параметров функции штрафа, которая бы позволила выполнить все условия
с минимальным числом броневиков и издержками. 
Было протестировано число броневиков 6 (успешно), 5 (успешно), 4 (не успешно).

АЛГОРИТМ РЕАЛИЗОВАН ПОСЛЕДОВАТЕЛЬНО ПО ДНЯМ, НЕ БЫЛО НЕОБХОДИМОСТИ РАЗБИВАТЬ НА ТРЕНИРОВОЧНЫЙ И ТЕСТОВЫЙ НАБОР.
ЕСЛИ АЛГОРИТМ ПРОШЕЛ ТРЕНИРОВОЧНЫЙ ПЕРИОД, ОН МОГ БЫ ДАЛЕЕ НЕ ПРОЙТИ ТЕСТОВЫЙ. И НАОБОРОТ.

## opt_route_2.py
ИТОГОВЫЙ алгоритм поиска оптимальных маршрутов для N броневиков (в нашем случае 5) 
на ПРОГНОЗИРУЕМЫХ данных по приросту наличности. 

Добаботка класса OptRouteFinder с учетом того, что работаем с прогнозами. 
АЛГОРИТМ УСПЕШНО ОТРАБОТАЛ на 5 броневиках, подтвердив стабильность определенной в opt_route_1 функции штрафа и числа броневиков.

1. Ввиду неуверенности в прогнозах добавили работу с выбросами. Определили на обучающем периоде терминалы, для которых характерны большИе выбросы 
(более 300000/500000 руб и отклонением больше 1 сигмы от среднего в бОльшую сторону) и бинарно отметили их для алгоритма.
Добавили параметры:
    outlier_limit=300000, # с какой суммы начинаем учитывать терминалы с выбросами в функции штрафов
    koef_outlier = 0.1): # коэф. при параметре "терминалы с фактами выбросов" в функции штрафов
И мотивировали алгоритм почаще заезжать в такие терминалы через функцию штрафов и koef_outlier .
2. В случае, если факт прироста все же сильно превысил наш прогноз, и точку мы не обсужили (на конец дня случилось переполнение),
на след. день она попадает в список ОБЯЗАТЕЛЬНЫХ.
3. Добавили расчет финансовых издержек на факте уже после отработки части "определения оптимального маршрута"
4. Стали сохранять больше промежуточных результатов. 

**ОСНОВНЫЕ методы:**
.balance # баланс
.all_terms_set # все терминалы
.bags # кейсы, когда в точку обязательно нужно было заехать, но алгоритм не направил туда броневик (не заехали)
.costs_without_vehicle_sum # общие издержки без броневиков
.cycle_time # время отработки на 1 дне (соотв на 91 дне - cycle_time*91)
.day_df_dict # промежуточные данные по дням
.distance_matrix # матрица времени/расстояния для графа
.num_veh # число машин
.over_balance_limit  # терминал не был переполнен, но к концу дня переполнился (на след. день попадает в обязательные)
.predictions # прогнозы прироста от модели
.problem_tid_lst # терминалы, определенные как "нестабильные", с выбросами
.route_vehicle # маршруты броневиков по дням и машинам (ВАЖНО!! терминалы - это "порядковый номер -1", не ID)
.terms_dict # терминалы, которые обсуживаем по дням
.time_vehicle # время в пути (с обслуживанием) броневиков

## opt_route_3.py
Поиск оптимального маршрута для одного (нового) дня

## cash_predict.py
Результат работы над подзадачей "прогноз приростов наличности в терминалах".

Класс CashPredict реализует  модель прогноза временных рядов SARIMA для всех представленных в данных банковских терминалов. Для каждого терминала строится своя авторегрессионная модель. На этапе обучения модели (методы .fit_model, .fit_models) проводится кросс-валидационный поиск наилучший модели для данного ряда из пула моделей с различным сочетанием параметров сезонной авторегрессии (p=[1..5], d=[0..2], q[1..5])(P[1..5], D[0..1], Q[1..5], S=7) по критерию Акаике. На этапе исследования данных была проверена стационарность исходных данных - максимальной порядок дифференцирования до достижения стационарности составил d=2 (подробности в файле cash forecast.ipynb).

Обучение моделей производится только на train наборе данных (диапазон всех данных минус self.days_for_test=30 при инициировании объекта по умолчанию)

**ОСНОВНЫЕ методы:**
.fit_model(tid) # если модель не обучена, запускает процесс обучения и выбора наилучшей модели на имеющемся train наборе данных для одного tid
.fit_models() # запускает процесс обучения и выбора наилучшей модели  для всех терминалов
.predict(id) # формирует прогноз для данного tid, если модели нет, сначала выполняет .fit
.predict_all() # возвращает результат .predict по всем терминалам
.predict_out(tid, days_out_of_data) # возвращает результат прогнозирования за пределами предоставленных данных (train + test), при этом модель не переобучается на всех данных, в комментариях есть реализация данного метода, который переобучает модель на всех данных, не производя при этом кросс-валидационного выбора (то есть параметры авторегрессии остаются теми, которые были определены как наилучшие на train данных), соответственно, такой метод будет отрабатывать достаточно быстро и лучше подходит для эксплуатации решения
.calc_error(tid) # вычисление ошибки прогнозирования - rmse, результаты теста Льюинга-Бокса на остатках
.show_prediction(tid) # выводит график исходного ряда и прогнозных значений (на train данных результат обучения, на test - результат прогноза)
.show_acf(tid) # выводит графики ACF/PACF для остатков раздельно для train (показывает качество полученной модели) и для test (показывает качество генерализации выбранного подхода)

# ФАЙЛЫ ДЛЯ ЗАПУСКА

- opt_route_1_run.py - запуск расчетов под opt_route_1.py и сохранение в формате pickle 
- opt_route_2_run.py - запуск расчетов под opt_route_2.py и сохранение в формате pickle
- opt_route_3_run.py - - запуск расчетов под opt_route_3.py и сохранение в формате pickle
- cash_predict_fit_new_run.py - создание нового объекта класса CashPredict без моделей, позволяет самостоятельно пройти весь путь получения моделей
- cash_predict_read_pkl_run.py - загрузка pickle объекта класса CashPredict, содержащего все модели, обученные на стадии подготовки решения

# НОУТБУКИ

- opt_route_finder_fact.ipynb - подгрузка решения, рассчитаного на ресурсах СберКлауд с возможностью потрогать результаты + "завернутый" в ноутбук класс OptRouteFinder(opt_route_2.py)
- opt_num_vehicle_finder.ipynb - подгрузка решения, рассчитаного на ресурсах СберКлауд с возможностью потрогать результаты + "завернутый" в ноутбук класс OptRouteFinder(opt_route_1.py)
- car_count_ideas.ipynb - работа над задачей "поиск оптимального кол-ва броневиков" в разрезе идей (если хочется понять поток мыслей)
- outliers.ipynb - анализ выбросов в приростах и в прогнозах
- report.ipynb - формирование отчёта
- one_day_test.ipynb - запуск скрипта составления оптимального маршрута на один (новый) день
- forecast.ipynb - весь анализ данных, обоснование выбранного способа прогнозирование, исследование альтернативных подходов к решению, сравнение результатов, визуализация основных результатов

# ДАННЫЕ

- /data - папка с данными для расчетов и pickle файлом готовых моделей
- /CloudRun1 - успешно отработавшие на этапе определения числа броневиков алгоритмы
- /CloudRun5 - успешно отработавшие на этапе построения маршрутов с прогнозными данными алгоритмы
- /ortools - исполняемые файлы or-tools
* по запросу выгрузим кейсы, не показавшие хорошие результаты 

[CCЫЛКА НА ФАЙЛЫ В ZIP](https://drive.google.com/drive/folders/1Ss_Vh3_UIWJ1G88YBHa_DKNEj7kNEW9j?usp=sharing)

# ВАЖНЫЕ МОМЕНТЫ

Запускали расчёты на ресурсах СберКлауд на cycle_time=480 (т.е. 12 часов для всего периода).
Уместить все необходимые для объезда точки в 4 машины не вышло.
Для 5 машин сработали параметры: 
predict_cash_trust=0.9, koef_priority_0 = 10000000, koef_step_func=1 И НЕСКОЛЬКО ВАРИАНТОВ koef_nes_degree - 2.6, 2.8, 3.4, 3.6

Далее только эти параметры использовали для тюнинга класса на прогнозных данных +
outlier_limit - 300000, 500000 и koef_outlier - 0, 0.1, 0.2

В результате отработали хорошо (в рамках 5 машин и 12ч рабочего дня без пропуска обязательных точек) только варианты с koef_outlier = 0. 
Таким образом, обязывая машины заезжать в терминалы с выбросами,
(при чем с т.зр незнания завтрашнего дня мы не можем сказать будет выброс завтра или через месяц) мы не умещаемся в 5 машин. 

В РЕЗУЛЬТАТЕ БЫЛ ВЫБРАН ВАРИАНТ c наименьшим коэффициентом koef_nes_degree, т.к. его увеличение "перетягивает" на себя и делает менее значимым
влияние затрат на обслуживание и фондирование в функции штрафов.

    predict_cash_trust=0.9, 
    num_veh = 5,
    cycle_time=480,
    koef_priority_0 = 10000000,
    koef_nes_degree=2.6, 
    koef_step_func=1,
    koef_costs_without_vehicle=10000,
    outlier_limit= 500000,
    koef_outlier = 0.

ВСЕ ПАРАМЕТРЫ МОЖНО ПРОВЕРИТЬ при обращении к классу после загрузки соответствующего pickle файла. 

# РАЗНОЧТЕНИЯ в отчете и ТЗ

* ОТЧЕТ - Лист "остатки на конец дня" показывает сумму остатков в устройствах в разрезе дат на конец дня. 
Т.е. в случае, если устройство было инкассировано, в ячейке точно должен быть 0

* ТЗ
Принимаем, что остаток в терминале увеличивается на сумму оборота в терминале разово. 
Т.е. утром известны остатки в терминалах и они не меняются за время работы бригад броневиков. Остатки на утро = остатки утра вчера  + обороты вчера.
Например, для терминала 406136 на утро 02.09 остаток = 250000, если 01.09 терминал не обслужили и = 90000, если терминал 01.09 обслужили.