CCЫЛКА НА КРУПНЫЕ ФАЙЛЫ: https://drive.google.com/file/d/1MrppSf857Vbyi0XovviPmppX6q5S81fy/view?usp=sharing
________________________________________________________________________
ОСНОВНЫЕ ФАЙЛЫ

opt_route_1.py - результат работы над задачей "поиск оптимального числа броневиков".

Класс OptRouteFinder представляет собой алгоритм поиска оптимальных маршрутов при необходимости выполнения заданных в ТЗ условий:
1) обязательно обслуживать терминал, если терминал сегодня будет переполнен
2) обязательно обслуживать терминал раз в 14 дней
Использовался на ФАКТИЧЕСКИХ ДАННЫХ для подбора параметров функции штрафа, которая бы позволила выполнить все условия
с минимальным числом броневиков и издержками. 
Было протестировано число броневиков 6 (успешно), 5 (успешно), 4 (не успешно).

АЛГОРИТМ РЕАЛИЗОВАН ПОСЛЕДОВАТЕЛЬНО ПО ДНЯМ, НЕ БЫЛО НЕОБХОДИМОСТИ РАЗБИВАТЬ НА ТРЕНИРОВОЧНЫЙ И ТЕСТОВЫЙ НАБОР.
ЕСЛИ АЛГОРИТМ ПРОШЕЛ ТРЕНИРОВОЧНЫЙ ПЕРИОД, ОН МОГ БЫ ДАЛЕЕ НЕ ПРОЙТИ ТЕСТОВЫЙ. И НАОБОРОТ.
________________________________________________________________________
opt_route_2.py  - ИТОГОВЫЙ алгоритм поиска оптимальных маршрутов для N броневиков (в нашем случае 5) 
на ПРОГНОЗИРУЕМЫХ данных по приросту наличности. 

Добаботка класса OptRouteFinder с учетом того, что работаем с прогнозами. 
АЛГОРИТМ УСПЕШНО ОТРАБОТАЛ на 5 броневиках, подтвердив стабильность определенной в opt_route_1 функции штрафа и числа броневиков.

1. Ввиду неуверенности в прогнозах добавили работу с выбросами. Определили на обучающем периоде терминалы, для которых характерны большИе выбросы 
(более 300000/500000 руб и отклонением больше 1 сигмы от среднего в бОльшую сторону) и бинарно отметили их для алгоритма.
Добавили параметры:
    outlier_limit=300000, # с какой суммы начинаем учитывать терминалы с выбросами в функции штрафов
    koef_outlier = 0.1): # коэф. при параметре "терминалы с фактами выбросов" в функции штрафов
И мотивировали алгоритм почаще заезжать в такие терминалы через функцию штрафов и koef_outlier .

2. В случае, если факт прироста все же сильно превысил наш прогноз, и точку мы не обсужили (на конец дня случилось переполнение),
на след. день она попадает в список ОБЯЗАТЕЛЬНЫХ.

3. Добавили расчет финансовых издержек на факте уже после отработки части "определения оптимального маршрута"

4. Стали сохранять больше промежуточных результатов. 

ОСНОВНЫЕ методы :

.balance # баланс
.all_terms_set # все терминалы
.bags # кейсы, когда в точку обязательно нужно было заехать, но алгоритм не направил туда броневик (не заехали)
.costs_without_vehicle_sum # общие издержки без броневиков
.cycle_time # время отработки на 1 дне (соотв на 91 дне - cycle_time*91)
.day_df_dict # промежуточные данные по дням
.distance_matrix # матрица времени/расстояния для графа
.num_veh # число машин
.over_balance_limit  # терминал не был переполнен, но к концу дня переполнился (на след. день попадает в обязательные)
.predictions # прогнозы прироста от модели
.problem_tid_lst # терминалы, определенные как "нестабильные", с выбросами
.route_vehicle # маршруты броневиков по дням и машинам (ВАЖНО!! терминалы - это "порядковый номер -1", не ID)
.terms_dict # терминалы, которые обсуживаем по дням
.time_vehicle # время в пути (с обслуживанием) броневиков

__________________________________________________________________________
opt_route_3.py - поиск оптимального маршрута для одного (нового) дня
___________________________________________________________________________
ФАЙЛЫ ДЛЯ ЗАПУСКА

opt_route_1_run.py - запуск расчетов под opt_route_1.py и сохранение в формате pickle 
opt_route_2_run.py - запуск расчетов под opt_route_2.py и сохранение в формате pickle
opt_route_3_run.py - - запуск расчетов под opt_route_3.py и сохранение в формате pickle
____________________________________________________________________________
НОУТБУКИ

opt_route_finder_fact.ipynb - подгрузка решения, рассчитаного на ресурсах СберКлауд с возможностью потрогать результаты + "завернутый" в ноутбук класс OptRouteFinder(opt_route_2.py)
opt_num_vehicle_finder.ipynb - подгрузка решения, рассчитаного на ресурсах СберКлауд с возможностью потрогать результаты + "завернутый" в ноутбук класс OptRouteFinder(opt_route_1.py)
car_count_ideas.ipynb - работа над задачей "поиск оптимального кол-ва броневиков" в разрезе идей (если хочется понять поток мыслей)
outliers.ipynb - анализ выбросов в приростах и в прогнозах
report.ipynb - формирование отчёта
one_day_test.ipynb - запуск скрипта составления оптимального маршрута на один (новый) день
____________________________________________________________________________
ДАННЫЕ

data - папка с данными для расчетов
CloudRun1 - успешно отработавшие на этапе определения числа броневиков алгоритмы
CloudRun5 - успешно отработавшие на этапе построения маршрутов с прогнозными данными алгоритмы
* по запросу выгрузим кейсы, не показавшие хорошие результаты 

CCЫЛКА НА КРУПНЫЕ ФАЙЛЫ: https://drive.google.com/file/d/1MrppSf857Vbyi0XovviPmppX6q5S81fy/view?usp=sharing
_____________________________________________________________________________
ВАЖНЫЕ МОМЕНТЫ

Запускали расчёты на ресурсах СберКлауд на cycle_time=480 (т.е. 12 часов для всего периода).
Уместить все необходимые для объезда точки в 4 машины не вышло.
Для 5 машин сработали параметры: 
predict_cash_trust=0.9, koef_priority_0 = 10000000, koef_step_func=1 И НЕСКОЛЬКО ВАРИАНТОВ koef_nes_degree - 2.6, 2.8, 3.4, 3.6

Далее только эти параметры использовали для тюнинга класса на прогнозных данных +
outlier_limit - 300000, 500000 и koef_outlier - 0, 0.1, 0.2

В результате отработали хорошо (в рамках 5 машин и 12ч рабочего дня без пропуска обязательных точек) только варианты с koef_outlier = 0. 
Таким образом, обязывая машины заезжать в терминалы с выбросами,
(при чем с т.зр незнания завтрашнего дня мы не можем сказать будет выброс завтра или через месяц) мы не умещаемся в 5 машин. 

В РЕЗУЛЬТАТЕ БЫЛ ВЫБРАН ВАРИАНТ c наименьшим коэффициентом koef_nes_degree, т.к. его увеличение "перетягивает" на себя и делает менее значимым
влияние затрат на обслуживание и фондирование в функции штрафов.

    predict_cash_trust=0.9, 
    num_veh = 5,
    cycle_time=480,
    koef_priority_0 = 10000000,
    koef_nes_degree=2.6, 
    koef_step_func=1,
    koef_costs_without_vehicle=10000,
    outlier_limit= 500000,
    koef_outlier = 0.

ВСЕ ПАРАМЕТРЫ МОЖНО ПРОВЕРИТЬ при обращении к классу после загрузки соответствующего pickle файла. 

____________________________________________________________________________
РАЗНОЧТЕНИЯ в отчете и ТЗ

**ОТЧЕТ - Лист "остатки на конец дня" показывает сумму остатков в устройствах в разрезе дат на конец дня. 
Т.е. в случае, если устройство было инкассировано, в ячейке точно должен быть 0

**ТЗ
Принимаем, что остаток в терминале увеличивается на сумму оборота в терминале разово. 
Т.е. утром известны остатки в терминалах и они не меняются за время работы бригад броневиков. Остатки на утро = остатки утра вчера  + обороты вчера.
Например, для терминала 406136 на утро 02.09 остаток = 250000, если 01.09 терминал не обслужили и = 90000, если терминал 01.09 обслужили.